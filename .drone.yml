---
global-variables:
  testrunner-image: &testrunner-image quay.io/ukhomeofficedigital/tf-testrunner:32 # TF0.12
#  testrunner-image: &testrunner-image quay.io/ukhomeofficedigital/tf-testrunner:TF1.6
  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:v0.23.18 # TF0.12
#  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:v0.26.2 # TF0.13
#  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:v0.28.6 # TF0.14
#  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:v0.30.7 # TF0.15
#  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:v0.35.20 # TF1.0
#  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:v0.48.5 # TF1.5
#  terragrunt-image: &terragrunt-image quay.io/ukhomeofficedigital/dq-docker-terragrunt:TGv0.54.4_TFv1.6.6
  vault-image: &vault-image docker.digital.homeoffice.gov.uk/dq/dq-vault-awscli:1.43

kind: pipeline
name: default
type: kubernetes

platform:
  os: linux
  arch: amd64

environment:
  BUCKET: dq-tf-infra-terraform-state
#  BUCKET: terraform-statefiles-all-envs
  STATE_FILE: dq-tf-infra
  TF_VERSION: 0.12
#  TF_VERSION: 1.6
  AWS_REGION: eu-west-2
  DEPLOYMENT_TYPE: dq-tf-infra

x-anchors:
  retrieve-state-aws-key: &retrieve-state-aws-key
    - vault --version
    # All Terraform State is held in an S3 Bucket - normally this is in the 'test' AWS Account
    # BUT dq-tf-infra NotProd and Prod deployments' Terraform State is held in an S3 Bucket in the 'CI' AWS Account
    # - so all Terraform steps will need to source AWS_SECRETS_FILE
    - export AWS_ENV="state"
    - export AWS_CREDS_FILE="aws_creds_$${AWS_ENV}.json"
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    # Retrieve vault secrets
    - vault read aws_dacc_dq/creds/drone > $${AWS_CREDS_FILE}
    - export LEASE_ID=$(cat $${AWS_CREDS_FILE} | grep lease_id | awk -F ' ' '{print $2}')
    - export ACCESS_KEY=$(cat $${AWS_CREDS_FILE} | grep access_key | awk -F ' ' '{print $2}')
    - export SECRET_KEY=$(cat $${AWS_CREDS_FILE} | grep secret_key | awk -F ' ' '{print $2}')
    # Update the token TTL to 10mins
    - vault lease renew -increment=3600 $${LEASE_ID}
    # Get the AWS credentials - for `Terragrunt/Terraform`
    - echo "export AWS_ACCESS_KEY_ID=$${ACCESS_KEY}" > $${AWS_SECRETS_FILE}
    - echo "export AWS_SECRET_ACCESS_KEY=$${SECRET_KEY}" >> $${AWS_SECRETS_FILE}
    - echo "export AWS_DEFAULT_REGION=$${AWS_REGION}" >> $${AWS_SECRETS_FILE}

  retrieve-ci-aws-key: &retrieve-ci-aws-key
    - vault --version
    # Set AWS Account from step's environment variable AWS_ENV
    - export AWS_ENV="ci"
    - export AWS_CREDS_FILE="aws_creds_$${AWS_ENV}.json"
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    # Retrieve vault secrets
    - vault read aws_dacc_dq/creds/drone > $${AWS_CREDS_FILE}
    - export LEASE_ID=$(cat $${AWS_CREDS_FILE} | grep lease_id | awk -F ' ' '{print $2}')
    - export ACCESS_KEY=$(cat $${AWS_CREDS_FILE} | grep access_key | awk -F ' ' '{print $2}')
    - export SECRET_KEY=$(cat $${AWS_CREDS_FILE} | grep secret_key | awk -F ' ' '{print $2}')
    # Update the token TTL to 10mins
    - vault lease renew -increment=3600 $${LEASE_ID}
    # Get the AWS credentials - to allow Terraform to deploy to the Target Account
    - echo "export TF_VAR_CI_ID=$${ACCESS_KEY}" > $${AWS_SECRETS_FILE}
    - echo "export TF_VAR_CI_KEY=$${SECRET_KEY}" >> $${AWS_SECRETS_FILE}
    - echo "export AWS_DEFAULT_REGION=$${AWS_REGION}" >> $${AWS_SECRETS_FILE}

  retrieve-deployment-aws-key: &retrieve-deployment-aws-key
    - vault --version
    # Set AWS Account from step's environment variable AWS_ENV
    - export AWS_CREDS_FILE="aws_creds_$${AWS_ENV}.json"
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    # Retrieve vault secrets
    - vault read aws_dacc_dq/creds/drone > $${AWS_CREDS_FILE}
    - export LEASE_ID=$(cat $${AWS_CREDS_FILE} | grep lease_id | awk -F ' ' '{print $2}')
    - export ACCESS_KEY=$(cat $${AWS_CREDS_FILE} | grep access_key | awk -F ' ' '{print $2}')
    - export SECRET_KEY=$(cat $${AWS_CREDS_FILE} | grep secret_key | awk -F ' ' '{print $2}')
    # Update the token TTL to 10mins
    - vault lease renew -increment=3600 $${LEASE_ID}
    # Get the AWS credentials - to allow Terraform to deploy to the Target Account
#    - echo "export TF_VAR_ENV_ACCT_ID=$${ACCESS_KEY}" > $${AWS_SECRETS_FILE}
#    - echo "export TF_VAR_ENV_ACCT_KEY=$${SECRET_KEY}" >> $${AWS_SECRETS_FILE}
    - echo "export TF_VAR_APPS_ID=$${ACCESS_KEY}" > $${AWS_SECRETS_FILE}
    - echo "export TF_VAR_APPS_KEY=$${SECRET_KEY}" >> $${AWS_SECRETS_FILE}
    - echo "export AWS_DEFAULT_REGION=$${AWS_REGION}" >> $${AWS_SECRETS_FILE}

  check-format: &check-format
    - terraform --version
    - terraform fmt --diff --check

  tf-init: &tf-init
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="set_aws_secrets_state.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for Target Account
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # Create config files for Terragrunt
    - echo -e "remote_state {\n  backend = \"s3\"\n  config = {\n  bucket = \"$BUCKET\"\n  region = \"$AWS_DEFAULT_REGION\"\n  dynamodb_table = \"terraform-state\"\n  key = \"$DEPLOYMENT_TYPE/terraform-$TF_VERSION/$AWS_ENV/$STATE_FILE.tfstate\"\n  encrypt = true \n  }\n}" > terragrunt.hcl
    # Add SSH_KEY to allow git clone
    - mkdir /root/.ssh && echo "$SSH_KEY" > /root/.ssh/id_rsa && chmod 0600 /root/.ssh/id_rsa
    - ssh-keyscan -t rsa -p 2222 gitlab.digital.homeoffice.gov.uk >>  ~/.ssh/known_hosts
    # INIT
    - terragrunt init -reconfigure

  tf-validate: &tf-validate
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="set_aws_secrets_state.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for Target Account
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # VALIDATE
    - terragrunt validate

  tf-plan: &tf-plan
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="set_aws_secrets_state.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for CI Account
    - export AWS_SECRETS_FILE="set_aws_secrets_ci.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for Target Account
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # Make Domain Joiner password available within TF (don't know why yet)
    - export TF_VAR_DOMAIN_JOINER_PWD=$${DOMAIN_JOINER_PWD}
    # PLAN
    - terragrunt plan -lock=false -out=plan_$${AWS_ENV}

  tf-apply: &tf-apply
    # Get AWS secrets for TF State
    - export AWS_SECRETS_FILE="set_aws_secrets_state.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for CI Account
    - export AWS_SECRETS_FILE="set_aws_secrets_ci.sh"
    - source $${AWS_SECRETS_FILE}
    # Get AWS secrets for Target Account
    - export AWS_SECRETS_FILE="set_aws_secrets_$${AWS_ENV}.sh"
    - source $${AWS_SECRETS_FILE}
    # APPLY
    - terragrunt apply -auto-approve -parallelism=50 plan_$${AWS_ENV}

steps:
  # Used to access TF state-file
- name: retrieve-aws-secrets-tf-state
  pull: always
  image: *vault-image
  commands: *retrieve-state-aws-key
  environment:
    # At present the statefiles are held in CI (=SIT)
    VAULT_ADDR:
      from_secret: VAULT_ADDR_SIT
    VAULT_TOKEN:
      from_secret: VAULT_TOKEN_SIT
#    VAULT_ADDR:
#      from_secret: VAULT_ADDR_DEV
#    VAULT_TOKEN:
#      from_secret: VAULT_TOKEN_DEV
  when:
    event:
      - push
      - promote

  # Used to access CI account (unsure why, related to AD Password?)
- name: retrieve-aws-secrets-tf-ci
  pull: always
  image: *vault-image
  commands: *retrieve-ci-aws-key
  environment:
    VAULT_ADDR:
      from_secret: VAULT_ADDR_SIT
    VAULT_TOKEN:
      from_secret: VAULT_TOKEN_SIT
  when:
    event:
      - push
      - promote

- name: check-format
  pull: if-not-exists
  image: *terragrunt-image
  commands: *check-format
  when:
    event:
      - push
    branch:
      exclude:
        - master

  # AWS 'NotProd' account Secrets - used to deploy to 'NotProd' account
- name: retrieve-aws-secrets-notprod
  pull: if-not-exists
  image: *vault-image
  commands: *retrieve-deployment-aws-key
  environment:
    AWS_ENV: notprod
    VAULT_ADDR:
      from_secret: VAULT_ADDR_NOTPROD
    VAULT_TOKEN:
      from_secret: VAULT_TOKEN_NOTPROD
  when:
    branch:
      exclude:
        - master

#- name: init
#  pull: always
#  image: *terragrunt-image
#  commands:
#  - export TF_VAR_APPS_ID=$${NOTPROD_ACC_ID}
#  - export TF_VAR_APPS_KEY=$${NOTPROD_ACC_KEY}
#  - mkdir /root/.ssh && echo "$SSH_KEY" > /root/.ssh/id_rsa && chmod 0600 /root/.ssh/id_rsa
#  - ssh-keyscan -t rsa -p 2222 gitlab.digital.homeoffice.gov.uk >>  ~/.ssh/known_hosts
#  - force-fail
#  - terragrunt init
#  environment:
#    AWS_ACCESS_KEY_ID:
#      from_secret: AWS_ACCESS_KEY_ID
#    AWS_SECRET_ACCESS_KEY:
#      from_secret: AWS_SECRET_ACCESS_KEY
#    NOTPROD_ACC_ID:
#      from_secret: NOTPROD_ACC_ID
#    NOTPROD_ACC_KEY:
#      from_secret: NOTPROD_ACC_KEY
#    SSH_KEY:
#      from_secret: SSH_KEY
#  when:
#    branch:
#      exclude:
#      - master

- name: init-notprod
  pull: if-not-exists
  image: *terragrunt-image
  commands: *tf-init
  environment:
    AWS_ENV: notprod
    SSH_KEY:
      from_secret: SSH_KEY
  when:
    branch:
      exclude:
        - master


#- name: testsuite
#  pull: if-not-exists
#  image: 340268328991.dkr.ecr.eu-west-2.amazonaws.com/acp/dind
#  commands:
#  - docker run --rm -v $(pwd):/data -w /data hashicorp/terraform fmt --diff --check
#  environment:
#    AWS_ACCESS_KEY_ID:
#      from_secret: AWS_ACCESS_KEY_ID
#    AWS_SECRET_ACCESS_KEY:
#      from_secret: AWS_SECRET_ACCESS_KEY
#    NOTPROD_ACC_ID:
#      from_secret: NOTPROD_ACC_ID
#    NOTPROD_ACC_KEY:
#      from_secret: NOTPROD_ACC_KEY
#  when:
#    branch:
#      exclude:
#      - master

#- name: validate
#  pull: if-not-exists
#  image: *terragrunt-image
#  commands:
#  - export TF_VAR_APPS_ID=$${NOTPROD_ACC_ID}
#  - export TF_VAR_APPS_KEY=$${NOTPROD_ACC_KEY}
#  - export CI_ID=$${TF_VAR_CI_ID}
#  - export CI_KEY=$${TF_VAR_CI_KEY}
#  - export TF_VAR_DOMAIN_JOINER_PWD=$${DOMAIN_JOINER_PWD}
#  - mkdir /root/.ssh && echo "$SSH_KEY" > /root/.ssh/id_rsa && chmod 0600 /root/.ssh/id_rsa
#  - ssh-keyscan -t rsa -p 2222 gitlab.digital.homeoffice.gov.uk >>  ~/.ssh/known_hosts
#  - terragrunt validate
#  environment:
#    AWS_ACCESS_KEY_ID:
#      from_secret: AWS_ACCESS_KEY_ID
#    AWS_SECRET_ACCESS_KEY:
#      from_secret: AWS_SECRET_ACCESS_KEY
#    DOMAIN_JOINER_PWD:
#      from_secret: DOMAIN_JOINER_PWD
#    NOTPROD_ACC_ID:
#      from_secret: NOTPROD_ACC_ID
#    NOTPROD_ACC_KEY:
#      from_secret: NOTPROD_ACC_KEY
#    SSH_KEY:
#      from_secret: SSH_KEY
#    TF_VAR_CI_ID:
#      from_secret: TF_VAR_CI_ID
#    TF_VAR_CI_KEY:
#      from_secret: TF_VAR_CI_KEY
#  when:
#    branch:
#      exclude:
#      - master

- name: validate-notprod
  pull: if-not-exists
  image: *terragrunt-image
  commands: *tf-validate
  environment:
    AWS_ENV: notprod
  when:
    branch:
      exclude:
        - master

#- name: plan-notprod
#  pull: always
#  image: *terragrunt-image
#  commands:
#  - export TF_VAR_APPS_ID=$${NOTPROD_ACC_ID}
#  - export TF_VAR_APPS_KEY=$${NOTPROD_ACC_KEY}
#  - export CI_ID=$${TF_VAR_CI_ID}
#  - export CI_KEY=$${TF_VAR_CI_KEY}
#  - export TF_VAR_DOMAIN_JOINER_PWD=$${DOMAIN_JOINER_PWD}
#  - mkdir /root/.ssh && echo "$SSH_KEY" > /root/.ssh/id_rsa && chmod 0600 /root/.ssh/id_rsa
#  - ssh-keyscan -t rsa -p 2222 gitlab.digital.homeoffice.gov.uk >>  ~/.ssh/known_hosts
#  - terragrunt plan -lock=false -out=plan
#  environment:
#    AWS_ACCESS_KEY_ID:
#      from_secret: AWS_ACCESS_KEY_ID
#    AWS_SECRET_ACCESS_KEY:
#      from_secret: AWS_SECRET_ACCESS_KEY
#    DOMAIN_JOINER_PWD:
#      from_secret: DOMAIN_JOINER_PWD
#    NOTPROD_ACC_ID:
#      from_secret: NOTPROD_ACC_ID
#    NOTPROD_ACC_KEY:
#      from_secret: NOTPROD_ACC_KEY
#    SSH_KEY:
#      from_secret: SSH_KEY
#    TF_VAR_CI_ID:
#      from_secret: TF_VAR_CI_ID
#    TF_VAR_CI_KEY:
#      from_secret: TF_VAR_CI_KEY
#  when:
#    event:
#    - push

- name: plan-notprod
  pull: if-not-exists
  image: *terragrunt-image
  commands: *tf-plan
  environment:
    AWS_ENV: notprod
    DOMAIN_JOINER_PWD:
      from_secret: DOMAIN_JOINER_PWD
  when: # Init, Plan & Apply when feature or master branch pushed
    event:
      - push

#- name: apply-notprod
#  pull: always
#  image: *terragrunt-image
#  commands:
#  - export TF_VAR_APPS_ID=$${NOTPROD_ACC_ID}
#  - export TF_VAR_APPS_KEY=$${NOTPROD_ACC_KEY}
#  - export CI_ID=$${TF_VAR_CI_ID}
#  - export CI_KEY=$${TF_VAR_CI_KEY}
#  - export TF_VAR_DOMAIN_JOINER_PWD=$${DOMAIN_JOINER_PWD}
#  - mkdir /root/.ssh && echo "$SSH_KEY" > /root/.ssh/id_rsa && chmod 0600 /root/.ssh/id_rsa
#  - ssh-keyscan -t rsa -p 2222 gitlab.digital.homeoffice.gov.uk >>  ~/.ssh/known_hosts
#  - terragrunt apply -auto-approve -parallelism=50 plan
#  environment:
#    AWS_ACCESS_KEY_ID:
#      from_secret: AWS_ACCESS_KEY_ID
#    AWS_SECRET_ACCESS_KEY:
#      from_secret: AWS_SECRET_ACCESS_KEY
#    DOMAIN_JOINER_PWD:
#      from_secret: DOMAIN_JOINER_PWD
#    NOTPROD_ACC_ID:
#      from_secret: NOTPROD_ACC_ID
#    NOTPROD_ACC_KEY:
#      from_secret: NOTPROD_ACC_KEY
#    SSH_KEY:
#      from_secret: SSH_KEY
#    TF_VAR_CI_ID:
#      from_secret: TF_VAR_CI_ID
#    TF_VAR_CI_KEY:
#      from_secret: TF_VAR_CI_KEY
#  when:
#    branch:
#      include:
#      - master
#      exclude:
#      - plan/*
#    event:
#    - push

# NOT YET TESTED - will test when merging to master
- name: apply-notprod
  pull: if-not-exists
  image: *terragrunt-image
  commands:
    *tf-apply
  environment:
    AWS_ENV: notprod
    TF_VAR_namespace: notprod
    TF_VAR_naming_suffix: apps-notprod-dq
  when:
    branch:
      include:
        - master
    event:
      - push

  # AWS 'Prod' account Secrets - used to deploy to 'Prod' account
- name: retrieve-aws-secrets-prod
  pull: if-not-exists
  image: *vault-image
  commands: *retrieve-deployment-aws-key
  environment:
    AWS_ENV: prod
    VAULT_ADDR:
      from_secret: VAULT_ADDR_PROD
    VAULT_TOKEN:
      from_secret: VAULT_TOKEN_PROD
  when:
    event:
      - promote
      - push

#- name: init-prod
#  pull: if-not-exists
#  image: *terragrunt-image
#  commands:
#  - export TF_VAR_APPS_ID=$${PROD_ACC_ID}
#  - export TF_VAR_APPS_KEY=$${PROD_ACC_KEY}
#  - export TF_VAR_DOMAIN_JOINER_PWD=$${DOMAIN_JOINER_PWD}
#  - mkdir /root/.ssh && echo "$SSH_KEY" > /root/.ssh/id_rsa && chmod 0600 /root/.ssh/id_rsa
#  - ssh-keyscan -t rsa -p 2222 gitlab.digital.homeoffice.gov.uk >>  ~/.ssh/known_hosts
#  - terragrunt init -reconfigure
#  environment:
#    AWS_ACCESS_KEY_ID:
#      from_secret: AWS_ACCESS_KEY_ID
#    AWS_SECRET_ACCESS_KEY:
#      from_secret: AWS_SECRET_ACCESS_KEY
#    DOMAIN_JOINER_PWD:
#      from_secret: DOMAIN_JOINER_PWD
#    PROD_ACC_ID:
#      from_secret: PROD_ACC_ID
#    PROD_ACC_KEY:
#      from_secret: PROD_ACC_KEY
#    SSH_KEY:
#      from_secret: SSH_KEY
#    TF_VAR_NAMESPACE: prod
#  when:
#    event:
#    - promote
#    - push

- name: init-prod
  pull: if-not-exists
  image: *terragrunt-image
  commands: *tf-init
  environment:
    AWS_ENV: prod
    SSH_KEY:
      from_secret: SSH_KEY
  when:
    event:
      - promote
      - push

#- name: plan-prod
#  pull: always
#  image: *terragrunt-image
#  commands:
#  - export TF_VAR_APPS_ID=$${PROD_ACC_ID}
#  - export TF_VAR_APPS_KEY=$${PROD_ACC_KEY}
#  - export CI_ID=$${TF_VAR_CI_ID}
#  - export CI_KEY=$${TF_VAR_CI_KEY}
#  - export TF_VAR_DOMAIN_JOINER_PWD=$${DOMAIN_JOINER_PWD}
#  - mkdir /root/.ssh && echo "$SSH_KEY" > /root/.ssh/id_rsa && chmod 0600 /root/.ssh/id_rsa
#  - ssh-keyscan -t rsa -p 2222 gitlab.digital.homeoffice.gov.uk >>  ~/.ssh/known_hosts
#  - terragrunt plan -lock=false -out=prodplan
#  environment:
#    AWS_ACCESS_KEY_ID:
#      from_secret: AWS_ACCESS_KEY_ID
#    AWS_SECRET_ACCESS_KEY:
#      from_secret: AWS_SECRET_ACCESS_KEY
#    DOMAIN_JOINER_PWD:
#      from_secret: DOMAIN_JOINER_PWD
#    PROD_ACC_ID:
#      from_secret: PROD_ACC_ID
#    PROD_ACC_KEY:
#      from_secret: PROD_ACC_KEY
#    SSH_KEY:
#      from_secret: SSH_KEY
#    TF_VAR_CI_ID:
#      from_secret: TF_VAR_CI_ID
#    TF_VAR_CI_KEY:
#      from_secret: TF_VAR_CI_KEY
#    TF_VAR_NAMESPACE: prod
#  when:
#    event:
#    - promote
#    - push

- name: plan-prod
  pull: if-not-exists
  image: *terragrunt-image
  commands: *tf-plan
  environment:
    AWS_ENV: prod
    DOMAIN_JOINER_PWD:
      from_secret: DOMAIN_JOINER_PWD
  when:
    event:
      - promote
      - push

- name: apply-prod
  pull: always
  image: *terragrunt-image
  commands:
  - export TF_VAR_APPS_ID=$${PROD_ACC_ID}
  - export TF_VAR_APPS_KEY=$${PROD_ACC_KEY}
  - export CI_ID=$${TF_VAR_CI_ID}
  - export CI_KEY=$${TF_VAR_CI_KEY}
  - export TF_VAR_DOMAIN_JOINER_PWD=$${DOMAIN_JOINER_PWD}
  - mkdir /root/.ssh && echo "$SSH_KEY" > /root/.ssh/id_rsa && chmod 0600 /root/.ssh/id_rsa
  - ssh-keyscan -t rsa -p 2222 gitlab.digital.homeoffice.gov.uk >>  ~/.ssh/known_hosts
  - terragrunt apply -auto-approve -parallelism=50 prodplan
  environment:
    AWS_ACCESS_KEY_ID:
      from_secret: AWS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY:
      from_secret: AWS_SECRET_ACCESS_KEY
    DOMAIN_JOINER_PWD:
      from_secret: DOMAIN_JOINER_PWD
    PROD_ACC_ID:
      from_secret: PROD_ACC_ID
    PROD_ACC_KEY:
      from_secret: PROD_ACC_KEY
    SSH_KEY:
      from_secret: SSH_KEY
    TF_VAR_CI_ID:
      from_secret: TF_VAR_CI_ID
    TF_VAR_CI_KEY:
      from_secret: TF_VAR_CI_KEY
    TF_VAR_NAMESPACE: prod
  when:
    branch:
      include:
      - master
      exclude:
      - plan/*
    event:
    - promote
    target:
    - prod

#services:
#  - name: docker
#    image: 340268328991.dkr.ecr.eu-west-2.amazonaws.com/acp/dind
